# Data Model: Dashboard Feature

**Feature**: User Dashboard for Wallet Management
**Date**: 2025-10-22
**Status**: Updated with Session 2025-10-22 clarifications

## Overview

This document defines all entities, their attributes, relationships, validation rules, and state transitions for the ArcSign dashboard application. The model follows a three-tier architecture:

- **View Layer**: React (TypeScript) - UI components and user interactions
- **Controller Layer**: Tauri Rust - Backend logic, subprocess management, security enforcement
- **Model Layer**: Go CLI - Cryptographic operations, wallet management, USB storage

All sensitive cryptographic operations are handled by the Go CLI, which outputs structured JSON to stdout for machine consumption and logs/debug info to stderr for human consumption.

---

## Core Entities

### 1. Wallet

Represents a hierarchical deterministic (HD) wallet derived from a BIP39 mnemonic seed.

#### Attributes

| Field | Type | Required | Validation | Description |
|-------|------|----------|------------|-------------|
| `id` | UUID (string) | Yes | UUID v4 format | Unique wallet identifier generated by CLI |
| `name` | string | No | Max 50 chars, alphanumeric + spaces + dashes | User-assigned wallet name (default: "Wallet {timestamp}") |
| `created_at` | RFC3339 string | Yes | Valid RFC3339 timestamp | Wallet creation timestamp in UTC |
| `uses_passphrase` | boolean | Yes | true/false | Indicates if BIP39 passphrase (25th word) was used during creation |
| `addresses_file_path` | string | Yes | Relative path format | Relative path to addresses.json file (e.g., "wallets/{id}/addresses.json") |

#### Relationships

- **1:1** with **AddressesFile** - Each wallet has exactly one addresses.json file stored on USB
- **1:N** with **Address** - Each wallet contains exactly 54 addresses (constant in current version)

#### Identity Rules

- `id` is a UUID v4 generated by the CLI during wallet creation
- Wallet identity is cryptographically linked to the mnemonic phrase
- Same mnemonic with different passphrase produces different wallet ID

#### Validation Rules (FR-033 through FR-047)

```typescript
// Wallet name validation
const validateWalletName = (name: string): boolean => {
  return name.length > 0 &&
         name.length <= 50 &&
         /^[a-zA-Z0-9 -]+$/.test(name) && // Alphanumeric + spaces + dashes only
         !/[\/\\:\*\?"<>\|]/.test(name);   // No path separators or special chars
};
```

#### State Transitions

```
[Creating] ──(CLI success)──────────> [Created]
[Creating] ──(CLI error)────────────> [Error]
[Created] ──(user cancels backup)──> [Cancelled] ──> [Deleted]
[Created] ──(user confirms backup)─> [Active]
[Active] ───(rename)────────────────> [Active] (updates name)
[Active] ───(export)────────────────> [Active] (no state change)
[Active] ───(duplicate import)─────> [Active] (shows warning dialog)
```

#### Security Notes

- **Mnemonic phrase is NEVER stored in this entity**
- Only encrypted mnemonic exists on USB (managed by CLI)
- Dashboard never has direct access to mnemonic after creation/import
- Passphrase (if used) is never stored; required on each wallet access

---

### 2. Address

Represents a cryptocurrency address derived from a wallet using BIP44 hierarchical deterministic derivation.

#### Attributes

| Field | Type | Required | Validation | Description |
|-------|------|----------|------------|-------------|
| `blockchain` | string | Yes | 1-100 chars | Full blockchain name (e.g., "Bitcoin", "Ethereum") |
| `symbol` | string | Yes | 2-10 chars, uppercase | Blockchain ticker symbol (e.g., "BTC", "ETH", "SOL") |
| `coin_type` | uint32 | Yes | 0 to 2^31-1 | SLIP-44 registered coin type (e.g., 0 for BTC, 60 for ETH) |
| `account` | uint32 | Yes | Always 0 | BIP44 account index (hardened) - currently always 0 |
| `change` | uint32 | Yes | Always 0 | BIP44 change index (0 = external/receive, 1 = internal/change) |
| `index` | uint32 | Yes | Always 0 | BIP44 address index - currently always 0 |
| `address` | string | Yes | Format varies by blockchain | Derived cryptocurrency address string |
| `path` | string | Yes | BIP44 format `m/44'/{coin_type}'/0'/0/0` | Full BIP44 derivation path |
| `category` | enum | Yes | See categories below | Blockchain category for UI filtering |

#### Categories (enum)

```typescript
enum AddressCategory {
  BASE_CHAINS = "base",        // Top 30 by market cap
  LAYER_2 = "layer2",          // Layer 2 networks (ARB, OP, BASE, etc.)
  REGIONAL = "regional",       // Regional chains (KLAY, CRO, HT, ONE)
  COSMOS = "cosmos",           // Cosmos ecosystem (OSMO, JUNO, EVMOS, SCRT)
  ALTERNATIVE_EVM = "alt_evm", // Alternative EVM chains (FTM, CELO, GLMR, etc.)
  SPECIALIZED = "specialized"  // Specialized chains (KSM, ICX, XTZ, ZIL)
}
```

#### Address Format Validation by Chain

```typescript
// Bitcoin: Base58Check or Bech32
const validateBitcoinAddress = (addr: string): boolean => {
  return /^(1|3|bc1)[a-zA-HJ-NP-Z0-9]{25,62}$/.test(addr);
};

// Ethereum & EVM chains: 0x + 40 hex chars
const validateEvmAddress = (addr: string): boolean => {
  return /^0x[a-fA-F0-9]{40}$/.test(addr);
};

// Solana: Base58, 32-44 chars
const validateSolanaAddress = (addr: string): boolean => {
  return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(addr);
};

// Cosmos ecosystem: Bech32 with chain-specific prefix
const validateCosmosAddress = (addr: string, prefix: string): boolean => {
  return addr.startsWith(prefix) &&
         /^[a-z0-9]{39,59}$/.test(addr);
};
```

#### Relationships

- **N:1** with **Wallet** - Many addresses belong to one wallet
- Composite identity: (`wallet_id`, `coin_type`) must be unique

#### Display Rules

- Addresses displayed by market cap rank (Bitcoin first)
- Filterable by `category` enum
- Searchable by `blockchain` name or `symbol` (case-insensitive)
- Copy-to-clipboard for each address with visual feedback

---

### 3. AddressesFile

Represents the JSON file stored on USB containing all derived addresses for a wallet. This file is generated automatically by the CLI during wallet creation and read directly by the Dashboard for display.

#### Attributes

| Field | Type | Required | Validation | Description |
|-------|------|----------|------------|-------------|
| `schema_version` | string | Yes | Semver format (e.g., "1.0") | File format version for forward compatibility |
| `wallet_id` | UUID (string) | Yes | Must match parent wallet ID | Foreign key to wallet |
| `generated_at` | RFC3339 string | Yes | Valid RFC3339 timestamp | File generation timestamp |
| `total_count` | uint32 | Yes | Must equal 54 | Total number of addresses in array |
| `checksum` | string | Yes | SHA-256 hex (64 chars) | SHA-256 hash of addresses array for tamper detection |
| `addresses` | Address[] | Yes | Array length must equal `total_count` | Array of all derived addresses with full metadata |

#### File Location

```
{USB_PATH}/wallets/{wallet_id}/addresses.json
```

- **Relative path** (from CLI perspective): `wallets/{wallet_id}/addresses.json`
- **Absolute path** (Dashboard resolves): `{USB_PATH}/wallets/{wallet_id}/addresses.json`

#### File Format

```json
{
  "schema_version": "1.0",
  "wallet_id": "3c3e0aba-91e1-44d4-8b29-ec066d5acf0b",
  "generated_at": "2025-10-22T14:30:25Z",
  "total_count": 54,
  "checksum": "a3f5d8e9c1b2...",
  "addresses": [
    {
      "blockchain": "Bitcoin",
      "symbol": "BTC",
      "coin_type": 0,
      "account": 0,
      "change": 0,
      "index": 0,
      "address": "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
      "path": "m/44'/0'/0'/0/0",
      "category": "base"
    }
    // ... 53 more addresses
  ]
}
```

#### Checksum Validation

The `checksum` field is computed as SHA-256 hash of the serialized `addresses` array:

```typescript
const computeChecksum = (addresses: Address[]): string => {
  const serialized = JSON.stringify(addresses, null, 0); // Compact JSON
  const hash = SHA256(serialized);
  return hash.toString('hex');
};

const validateChecksum = (file: AddressesFile): boolean => {
  const computed = computeChecksum(file.addresses);
  return computed === file.checksum;
};
```

#### Error Handling (FR-040)

```typescript
enum AddressFileError {
  INVALID_SCHEMA = "INVALID_SCHEMA",     // schema_version mismatch
  INVALID_CHECKSUM = "INVALID_CHECKSUM", // Checksum verification failed
  FILE_NOT_FOUND = "FILE_NOT_FOUND",     // addresses.json missing
  PARSE_ERROR = "PARSE_ERROR"            // Invalid JSON
}
```

#### Security & Integrity

- **Read-only** by Dashboard (never modified directly)
- **Tamper detection** via SHA-256 checksum
- **Forward compatibility** via semantic versioning
- **No sensitive data** - only public addresses and derivation paths

---

### 4. CliResponse

Represents the successful JSON response from the Go CLI output to stdout. All CLI commands follow this structure for consistency.

#### Attributes

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `success` | boolean | Yes | Always `true` for successful operations |
| `wallet` | Wallet object | Conditional | Returned for create/import/list operations (optional) |
| `mnemonic` | string | Conditional | Only included if `RETURN_MNEMONIC=true` env var set (12 or 24 space-separated words) |
| `request_id` | UUID (string) | Yes | Unique identifier for tracing/debugging this CLI invocation |
| `cli_version` | string | Yes | Semantic version of CLI (e.g., "0.4.0") for compatibility checking |
| `duration_ms` | uint64 | Yes | Operation execution time in milliseconds for performance monitoring |
| `warnings` | string[] | Yes | Array of non-fatal warning messages (empty array if none) |

#### Example: Wallet Creation Response

```json
{
  "success": true,
  "wallet": {
    "id": "3c3e0aba-91e1-44d4-8b29-ec066d5acf0b",
    "name": "My Wallet",
    "created_at": "2025-10-22T14:30:25Z",
    "uses_passphrase": false,
    "addresses_file_path": "wallets/3c3e0aba-91e1-44d4-8b29-ec066d5acf0b/addresses.json"
  },
  "mnemonic": "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
  "request_id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "cli_version": "0.4.0",
  "duration_ms": 1247,
  "warnings": []
}
```

#### Example: Import Response (No Mnemonic Return)

```json
{
  "success": true,
  "wallet": {
    "id": "7d2a1f3e-4b5c-4321-9876-1234567890ab",
    "name": "Imported Wallet",
    "created_at": "2025-10-22T15:45:10Z",
    "uses_passphrase": true,
    "addresses_file_path": "wallets/7d2a1f3e-4b5c-4321-9876-1234567890ab/addresses.json"
  },
  "request_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "cli_version": "0.4.0",
  "duration_ms": 982,
  "warnings": [
    "BIP39 passphrase used - ensure you remember it for future access"
  ]
}
```

#### Security Considerations

- **Mnemonic exclusion by default**: `mnemonic` field is only included when `RETURN_MNEMONIC=true` environment variable is explicitly set
- **No sensitive data in warnings**: Warnings must not contain passwords, mnemonics, or private keys
- **stdout only**: Sensitive responses only on stdout (never stderr)

---

### 5. CliError

Represents the error response from the Go CLI when operations fail. Also output to stdout as JSON.

#### Attributes

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `success` | boolean | Yes | Always `false` for error responses |
| `error` | ErrorObject | Yes | Structured error information with code and message |
| `request_id` | UUID (string) | Yes | Same request ID for tracing |
| `cli_version` | string | Yes | CLI version for debugging compatibility issues |
| `duration_ms` | uint64 | Yes | Time elapsed before failure |

#### ErrorObject Structure

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `code` | ErrorCode enum | Yes | Machine-readable error code |
| `message` | string | Yes | Human-readable error description (sanitized, no sensitive data) |

#### Error Codes (FR-042)

```typescript
enum CliErrorCode {
  INVALID_PASSWORD = "INVALID_PASSWORD",     // Wrong encryption password
  USB_NOT_FOUND = "USB_NOT_FOUND",           // USB device not detected
  WALLET_EXISTS = "WALLET_EXISTS",           // Duplicate wallet ID
  CRYPTO_ERROR = "CRYPTO_ERROR",             // Cryptographic operation failed
  IO_ERROR = "IO_ERROR",                     // File system error
  TIMEOUT = "TIMEOUT",                       // Operation exceeded time limit
  INVALID_SCHEMA = "INVALID_SCHEMA",         // addresses.json schema version mismatch
  INVALID_CHECKSUM = "INVALID_CHECKSUM",     // addresses.json checksum verification failed
  INVALID_MNEMONIC = "INVALID_MNEMONIC",     // BIP39 validation failed
  INSUFFICIENT_SPACE = "INSUFFICIENT_SPACE"  // USB has <10MB free space
}
```

#### Example: Error Response

```json
{
  "success": false,
  "error": {
    "code": "USB_NOT_FOUND",
    "message": "USB device not detected at expected mount point. Please insert USB drive and try again."
  },
  "request_id": "e8f9a0b1-c2d3-4e5f-6789-0123456789ab",
  "cli_version": "0.4.0",
  "duration_ms": 150
}
```

#### Dashboard Error Handling Flow (FR-036, FR-037, FR-038)

```typescript
// Priority order for error parsing
const parseCliError = async (
  process: ChildProcess
): Promise<CliError> => {
  const exitCode = await process.wait();
  const stdout = await process.readStdout();
  const stderr = await process.readStderr();

  // 1. Try parsing stdout for JSON error response
  try {
    const response = JSON.parse(stdout);
    if (!response.success) {
      return response as CliError;
    }
  } catch (e) {
    // Not JSON or success=true, continue to stderr
  }

  // 2. Try parsing stderr for JSON error object
  try {
    const errorObj = JSON.parse(stderr);
    return {
      success: false,
      error: errorObj,
      request_id: "unknown",
      cli_version: "unknown",
      duration_ms: 0
    };
  } catch (e) {
    // Not JSON in stderr, continue
  }

  // 3. Use raw stderr message if available
  if (stderr.trim().length > 0) {
    return {
      success: false,
      error: {
        code: "IO_ERROR",
        message: stderr.trim()
      },
      request_id: "unknown",
      cli_version: "unknown",
      duration_ms: 0
    };
  }

  // 4. Fallback to generic message with exit code
  return {
    success: false,
    error: {
      code: "IO_ERROR",
      message: `Wallet operation failed with exit code ${exitCode}`
    },
    request_id: "unknown",
    cli_version: "unknown",
    duration_ms: 0
  };
};
```

#### Error Logging vs. User Display

```typescript
// Log full details to debug logs (developer-facing)
const logError = (error: CliError, stdout: string, stderr: string, exitCode: number) => {
  console.debug({
    error,
    stdout,
    stderr,
    exitCode,
    timestamp: new Date().toISOString()
  });
};

// Show sanitized message to user (no sensitive data)
const displayError = (error: CliError): string => {
  const userMessages: Record<CliErrorCode, string> = {
    INVALID_PASSWORD: "Incorrect password. Please try again.",
    USB_NOT_FOUND: "USB drive not detected. Please insert your ArcSign USB and try again.",
    WALLET_EXISTS: "This wallet already exists. Choose a different name or cancel.",
    CRYPTO_ERROR: "Encryption error occurred. Please try again or contact support.",
    IO_ERROR: "File system error. Check USB connection and try again.",
    TIMEOUT: "Operation timed out. Please check USB connection and try again.",
    INVALID_SCHEMA: "Wallet data format is incompatible. Please update ArcSign CLI.",
    INVALID_CHECKSUM: "Wallet data corrupted. Please restore from backup.",
    INVALID_MNEMONIC: "Invalid mnemonic phrase. Please check your backup and try again.",
    INSUFFICIENT_SPACE: "USB drive has insufficient space. Free at least 10MB and try again."
  };

  return userMessages[error.error.code] || error.error.message;
};
```

---

## Validation Rules

### Password Validation (FR-009, FR-033)

```typescript
interface PasswordRequirements {
  minLength: 12;
  requireUppercase: true;
  requireLowercase: true;
  requireNumber: true;
}

const validatePassword = (password: string): { valid: boolean; errors: string[] } => {
  const errors: string[] = [];

  if (password.length < 12) {
    errors.push("Password must be at least 12 characters");
  }
  if (!/[A-Z]/.test(password)) {
    errors.push("Password must contain at least one uppercase letter");
  }
  if (!/[a-z]/.test(password)) {
    errors.push("Password must contain at least one lowercase letter");
  }
  if (!/[0-9]/.test(password)) {
    errors.push("Password must contain at least one number");
  }

  return {
    valid: errors.length === 0,
    errors
  };
};
```

### Mnemonic Validation (FR-006, FR-030)

```typescript
const validateMnemonic = (input: string): { valid: boolean; error?: string } => {
  // 1. Normalize whitespace
  const normalized = input.trim().replace(/\s+/g, ' ');

  // 2. Split into words
  const words = normalized.split(' ');

  // 3. Check word count
  if (words.length !== 12 && words.length !== 24) {
    return {
      valid: false,
      error: `Invalid mnemonic length: expected 12 or 24 words, got ${words.length}`
    };
  }

  // 4. Validate each word against BIP39 wordlist
  const invalidWords = words.filter(word => !BIP39_WORDLIST.includes(word));
  if (invalidWords.length > 0) {
    return {
      valid: false,
      error: `Invalid words: ${invalidWords.join(', ')}`
    };
  }

  // 5. Verify BIP39 checksum
  if (!verifyBip39Checksum(words)) {
    return {
      valid: false,
      error: "Invalid mnemonic: checksum verification failed"
    };
  }

  return { valid: true };
};
```

### USB Path Validation (FR-024, FR-033)

```typescript
const validateUsbPath = async (path: string): Promise<{ valid: boolean; error?: string }> => {
  // 1. Check path exists
  if (!await fs.exists(path)) {
    return {
      valid: false,
      error: "USB path does not exist"
    };
  }

  // 2. Check write permissions
  if (!await fs.isWritable(path)) {
    return {
      valid: false,
      error: "USB path is not writable. Check permissions."
    };
  }

  // 3. Check available space (minimum 10MB)
  const freeSpace = await fs.getFreeSpace(path);
  if (freeSpace < 10 * 1024 * 1024) {
    return {
      valid: false,
      error: `Insufficient space on USB. Required: 10MB, Available: ${(freeSpace / 1024 / 1024).toFixed(2)}MB`
    };
  }

  return { valid: true };
};
```

### Wallet Name Validation (FR-019)

```typescript
const validateWalletName = (name: string): { valid: boolean; error?: string } => {
  if (name.length === 0) {
    return { valid: false, error: "Wallet name cannot be empty" };
  }

  if (name.length > 50) {
    return { valid: false, error: "Wallet name must be 50 characters or less" };
  }

  if (!/^[a-zA-Z0-9 -]+$/.test(name)) {
    return {
      valid: false,
      error: "Wallet name can only contain letters, numbers, spaces, and dashes"
    };
  }

  return { valid: true };
};
```

---

## State Transitions

### 1. Wallet Creation Flow

```
User clicks "Create Wallet"
    │
    ▼
[Form Validation]
    │ Validate password strength
    │ Validate wallet name
    │ Check USB availability
    ▼
[CLI Subprocess Invocation] (FR-033)
    │ Set ENV: WALLET_PASSWORD, USB_PATH, MNEMONIC_LENGTH
    │ Command: arcsign create --non-interactive
    │ Timeout: 30 seconds (FR-036)
    ▼
[Address Generation] (FR-035)
    │ CLI generates BIP39 mnemonic
    │ CLI derives all 54 addresses
    │ CLI computes checksum
    ▼
[addresses.json Write] (FR-040)
    │ Write to {USB_PATH}/wallets/{id}/addresses.json
    │ Include schema_version, checksum, full metadata
    ▼
[Success Response] (FR-039)
    │ CLI outputs CliResponse to stdout
    │ Dashboard parses JSON
    │ Display mnemonic (if RETURN_MNEMONIC=true)
    ▼
[User Confirmation]
    │ Show mnemonic with security warnings (FR-043-047)
    │ 30-second countdown
    │ Platform-specific screenshot protection
    ▼
[Wallet Active]
```

### 2. Wallet Import Flow

```
User clicks "Import Wallet"
    │
    ▼
[Mnemonic Input & Validation] (FR-030)
    │ Normalize whitespace
    │ Validate word count (12 or 24)
    │ Validate BIP39 wordlist
    │ Verify checksum
    │ Show inline errors immediately (FR-029)
    ▼
[Duplicate Check] (FR-031)
    │ Derive Bitcoin address at m/44'/0'/0'/0/0 in memory
    │ Compare against all existing addresses.json files
    │ If match found:
    │   ├─> Show warning dialog with existing wallet info
    │   ├─> Options: Cancel | Import Anyway (with new name)
    │   └─> User chooses
    ▼
[CLI Subprocess Invocation]
    │ Set ENV: WALLET_PASSWORD, USB_PATH, MNEMONIC, PASSPHRASE
    │ Command: arcsign import --non-interactive
    │ Timeout: 30 seconds
    ▼
[Address Generation]
    │ CLI derives all 54 addresses from imported mnemonic
    │ CLI computes checksum
    ▼
[addresses.json Write]
    │ Write to {USB_PATH}/wallets/{id}/addresses.json
    ▼
[Success Response]
    │ CLI outputs CliResponse to stdout (no mnemonic)
    │ Dashboard parses JSON
    ▼
[Wallet Active]
```

### 3. Address Display Flow

```
User selects wallet from list
    │
    ▼
[Dashboard reads addresses.json] (FR-041)
    │ Path: {USB_PATH} + wallet.addresses_file_path
    │ Parse JSON
    ▼
[Checksum Validation] (FR-040)
    │ Compute SHA-256 of addresses array
    │ Compare with file.checksum
    │ If mismatch:
    │   └─> Display error: "Wallet data corrupted. Restore from backup."
    ▼
[Schema Version Check] (FR-040)
    │ Verify schema_version is compatible
    │ If incompatible:
    │   └─> Display error: "Wallet format incompatible. Update CLI."
    ▼
[Address Rendering]
    │ Display addresses in UI
    │ Apply category filter
    │ Apply search query
    │ Enable copy-to-clipboard
    ▼
[Addresses Displayed]
```

### 4. Error Handling Flow

```
CLI subprocess encounters error
    │
    ▼
[Timeout Check] (FR-036)
    │ If operation exceeds 30 seconds:
    │   └─> Terminate subprocess
    │   └─> Display: "Operation timed out. Check USB and retry."
    ▼
[Parse Error Response] (FR-037)
    │ Priority 1: Parse stdout for JSON error object
    │ Priority 2: Parse stderr for JSON error object
    │ Priority 3: Use raw stderr message
    │ Priority 4: Generic error with exit code
    ▼
[Log Full Error Details] (FR-038)
    │ Write to debug logs:
    │   - exit_code
    │   - stdout
    │   - stderr
    │   - timestamp
    ▼
[Display Sanitized Error]
    │ Map error.code to user-friendly message
    │ Never show sensitive data
    │ Provide actionable guidance
    ▼
[User Sees Error Message]
```

---

## Relationships

### Entity Relationship Diagram

```
┌──────────────────────┐
│      Wallet          │
│ ─────────────────────│
│ id: UUID             │───┐
│ name: string         │   │
│ created_at: RFC3339  │   │
│ uses_passphrase: bool│   │ 1:1
│ addresses_file_path  │   │
└──────────────────────┘   │
                           │
                           ▼
              ┌─────────────────────────┐
              │    AddressesFile        │
              │ ────────────────────────│
              │ schema_version: semver  │
              │ wallet_id: UUID         │
              │ generated_at: RFC3339   │
              │ total_count: 54         │
              │ checksum: SHA-256       │
              │ addresses: Address[]    │──┐
              └─────────────────────────┘  │
                                           │ 1:N
                                           │
                                           ▼
                              ┌────────────────────────┐
                              │      Address           │
                              │ ───────────────────────│
                              │ blockchain: string     │
                              │ symbol: string         │
                              │ coin_type: u32         │
                              │ account: u32           │
                              │ change: u32            │
                              │ index: u32             │
                              │ address: string        │
                              │ path: string           │
                              │ category: enum         │
                              └────────────────────────┘
```

### Cardinality Rules

- **Dashboard : Wallet** = 1:N (Dashboard can manage up to 10 wallets)
- **Wallet : AddressesFile** = 1:1 (Each wallet has exactly one addresses.json file on USB)
- **AddressesFile : Address** = 1:N (Each file contains exactly 54 addresses)
- **Wallet : Address** = 1:N (Derived relationship: 1 wallet → 54 addresses)

---

## TypeScript Type Definitions

```typescript
// ============================================================================
// Core Entity Types
// ============================================================================

/**
 * Wallet entity representing a BIP39/BIP44 hierarchical deterministic wallet.
 * This is metadata only - the encrypted mnemonic is stored on USB.
 */
interface Wallet {
  /** Unique wallet identifier (UUID v4 generated by CLI) */
  id: string;

  /** User-assigned wallet name (max 50 chars, alphanumeric + spaces + dashes) */
  name?: string;

  /** Wallet creation timestamp in RFC3339 format */
  created_at: string;

  /** Whether BIP39 passphrase (25th word) was used during wallet creation */
  uses_passphrase: boolean;

  /** Relative path to addresses.json file (e.g., "wallets/{id}/addresses.json") */
  addresses_file_path: string;
}

/**
 * Address category for UI filtering and organization.
 */
enum AddressCategory {
  BASE_CHAINS = "base",
  LAYER_2 = "layer2",
  REGIONAL = "regional",
  COSMOS = "cosmos",
  ALTERNATIVE_EVM = "alt_evm",
  SPECIALIZED = "specialized"
}

/**
 * Cryptocurrency address derived from wallet using BIP44.
 */
interface Address {
  /** Full blockchain name (e.g., "Bitcoin", "Ethereum") */
  blockchain: string;

  /** Ticker symbol (e.g., "BTC", "ETH") - 2-10 chars uppercase */
  symbol: string;

  /** SLIP-44 registered coin type (e.g., 0 for BTC, 60 for ETH) */
  coin_type: number;

  /** BIP44 account index (hardened) - currently always 0 */
  account: number;

  /** BIP44 change index (0 = external/receive, 1 = internal/change) */
  change: number;

  /** BIP44 address index - currently always 0 */
  index: number;

  /** Derived cryptocurrency address string (format varies by chain) */
  address: string;

  /** Full BIP44 derivation path (e.g., "m/44'/0'/0'/0/0") */
  path: string;

  /** Blockchain category for filtering */
  category: AddressCategory;
}

/**
 * JSON file structure for addresses.json stored on USB.
 * Contains all derived addresses for a wallet with tamper detection.
 */
interface AddressesFile {
  /** Semantic version of file format (e.g., "1.0") for forward compatibility */
  schema_version: string;

  /** Foreign key to parent wallet */
  wallet_id: string;

  /** File generation timestamp in RFC3339 format */
  generated_at: string;

  /** Total number of addresses (must equal 54) */
  total_count: number;

  /** SHA-256 hash of addresses array (hex string, 64 chars) for tamper detection */
  checksum: string;

  /** Array of all derived addresses with full metadata */
  addresses: Address[];
}

// ============================================================================
// CLI Response Types
// ============================================================================

/**
 * Successful response from CLI operations.
 * Output to stdout as single-line JSON.
 */
interface CliResponse {
  /** Always true for successful operations */
  success: true;

  /** Wallet object (optional, returned for create/import/list operations) */
  wallet?: Wallet;

  /** BIP39 mnemonic phrase - ONLY included if RETURN_MNEMONIC=true env var set */
  mnemonic?: string;

  /** Unique request identifier for tracing/debugging */
  request_id: string;

  /** Semantic version of CLI (e.g., "0.4.0") */
  cli_version: string;

  /** Operation execution time in milliseconds */
  duration_ms: number;

  /** Array of non-fatal warning messages (empty if none) */
  warnings: string[];
}

/**
 * Error codes returned by CLI when operations fail.
 * Machine-readable codes for Dashboard error handling.
 */
enum CliErrorCode {
  INVALID_PASSWORD = "INVALID_PASSWORD",
  USB_NOT_FOUND = "USB_NOT_FOUND",
  WALLET_EXISTS = "WALLET_EXISTS",
  CRYPTO_ERROR = "CRYPTO_ERROR",
  IO_ERROR = "IO_ERROR",
  TIMEOUT = "TIMEOUT",
  INVALID_SCHEMA = "INVALID_SCHEMA",
  INVALID_CHECKSUM = "INVALID_CHECKSUM",
  INVALID_MNEMONIC = "INVALID_MNEMONIC",
  INSUFFICIENT_SPACE = "INSUFFICIENT_SPACE"
}

/**
 * Structured error information within CliError.
 */
interface ErrorObject {
  /** Machine-readable error code from enumerated set */
  code: CliErrorCode;

  /** Human-readable error description (sanitized, no sensitive data) */
  message: string;
}

/**
 * Error response from CLI when operations fail.
 * Output to stdout as JSON.
 */
interface CliError {
  /** Always false for error responses */
  success: false;

  /** Structured error information */
  error: ErrorObject;

  /** Request identifier for tracing */
  request_id: string;

  /** CLI version for debugging */
  cli_version: string;

  /** Time elapsed before failure (milliseconds) */
  duration_ms: number;
}

// ============================================================================
// Dashboard State Types
// ============================================================================

/**
 * Global application state managed by React/Zustand.
 * Transient state - not persisted to disk.
 */
interface DashboardState {
  /** Currently selected wallet ID (null if no wallet selected) */
  selected_wallet_id: string | null;

  /** Active category filter for address list */
  active_category_filter: AddressCategory | "all";

  /** Search query for filtering addresses by blockchain name or symbol */
  search_query: string;

  /** Array of all available wallets loaded from USB */
  wallets: Wallet[];

  /** Addresses for currently selected wallet (empty if no wallet selected) */
  addresses: Address[];

  /** Global loading indicator */
  is_loading: boolean;

  /** USB device detection status */
  usb_detected: boolean;

  /** Current USB mount point (null if not detected) */
  usb_path: string | null;
}

// ============================================================================
// Validation Types
// ============================================================================

/**
 * Password validation requirements.
 */
interface PasswordRequirements {
  minLength: 12;
  requireUppercase: true;
  requireLowercase: true;
  requireNumber: true;
}

/**
 * Validation result with detailed error messages.
 */
interface ValidationResult {
  valid: boolean;
  errors?: string[];
}

/**
 * Mnemonic validation result.
 */
interface MnemonicValidationResult {
  valid: boolean;
  error?: string;
}

// ============================================================================
// Utility Types
// ============================================================================

/**
 * USB validation result with error details.
 */
interface UsbValidationResult {
  valid: boolean;
  error?: string;
}

/**
 * Wallet name validation result.
 */
interface WalletNameValidationResult {
  valid: boolean;
  error?: string;
}
```

---

## Rust Type Definitions

```rust
// ============================================================================
// Core Entity Types (Tauri Rust Backend)
// ============================================================================

use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Wallet entity representing a BIP39/BIP44 hierarchical deterministic wallet.
/// This is metadata only - the encrypted mnemonic is stored on USB.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Wallet {
    /// Unique wallet identifier (UUID v4 generated by CLI)
    pub id: String,

    /// User-assigned wallet name (max 50 chars, alphanumeric + spaces + dashes)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Wallet creation timestamp in RFC3339 format
    pub created_at: String,

    /// Whether BIP39 passphrase (25th word) was used during wallet creation
    pub uses_passphrase: bool,

    /// Relative path to addresses.json file (e.g., "wallets/{id}/addresses.json")
    pub addresses_file_path: String,
}

/// Address category for UI filtering and organization.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum AddressCategory {
    #[serde(rename = "base")]
    BaseChains,

    #[serde(rename = "layer2")]
    Layer2,

    #[serde(rename = "regional")]
    Regional,

    #[serde(rename = "cosmos")]
    Cosmos,

    #[serde(rename = "alt_evm")]
    AlternativeEvm,

    #[serde(rename = "specialized")]
    Specialized,
}

/// Cryptocurrency address derived from wallet using BIP44.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Address {
    /// Full blockchain name (e.g., "Bitcoin", "Ethereum")
    pub blockchain: String,

    /// Ticker symbol (e.g., "BTC", "ETH") - 2-10 chars uppercase
    pub symbol: String,

    /// SLIP-44 registered coin type (e.g., 0 for BTC, 60 for ETH)
    pub coin_type: u32,

    /// BIP44 account index (hardened) - currently always 0
    pub account: u32,

    /// BIP44 change index (0 = external/receive, 1 = internal/change)
    pub change: u32,

    /// BIP44 address index - currently always 0
    pub index: u32,

    /// Derived cryptocurrency address string (format varies by chain)
    pub address: String,

    /// Full BIP44 derivation path (e.g., "m/44'/0'/0'/0/0")
    pub path: String,

    /// Blockchain category for filtering
    pub category: AddressCategory,
}

/// JSON file structure for addresses.json stored on USB.
/// Contains all derived addresses for a wallet with tamper detection.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddressesFile {
    /// Semantic version of file format (e.g., "1.0") for forward compatibility
    pub schema_version: String,

    /// Foreign key to parent wallet
    pub wallet_id: String,

    /// File generation timestamp in RFC3339 format
    pub generated_at: String,

    /// Total number of addresses (must equal 54)
    pub total_count: u32,

    /// SHA-256 hash of addresses array (hex string, 64 chars) for tamper detection
    pub checksum: String,

    /// Array of all derived addresses with full metadata
    pub addresses: Vec<Address>,
}

impl AddressesFile {
    /// Validates checksum of addresses array.
    pub fn validate_checksum(&self) -> Result<(), String> {
        let computed = self.compute_checksum();
        if computed != self.checksum {
            return Err(format!(
                "Checksum mismatch: expected {}, got {}",
                self.checksum, computed
            ));
        }
        Ok(())
    }

    /// Computes SHA-256 checksum of addresses array.
    fn compute_checksum(&self) -> String {
        use sha2::{Digest, Sha256};

        // Serialize addresses to compact JSON
        let serialized = serde_json::to_string(&self.addresses)
            .expect("Failed to serialize addresses");

        // Compute SHA-256 hash
        let mut hasher = Sha256::new();
        hasher.update(serialized.as_bytes());
        let result = hasher.finalize();

        // Convert to hex string
        hex::encode(result)
    }
}

// ============================================================================
// CLI Response Types
// ============================================================================

/// Successful response from CLI operations.
/// Deserialized from stdout JSON.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CliResponse {
    /// Always true for successful operations
    pub success: bool,

    /// Wallet object (optional, returned for create/import/list operations)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub wallet: Option<Wallet>,

    /// BIP39 mnemonic phrase - ONLY included if RETURN_MNEMONIC=true env var set
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mnemonic: Option<String>,

    /// Unique request identifier for tracing/debugging
    pub request_id: String,

    /// Semantic version of CLI (e.g., "0.4.0")
    pub cli_version: String,

    /// Operation execution time in milliseconds
    pub duration_ms: u64,

    /// Array of non-fatal warning messages (empty if none)
    pub warnings: Vec<String>,
}

/// Error codes returned by CLI when operations fail.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum CliErrorCode {
    InvalidPassword,
    UsbNotFound,
    WalletExists,
    CryptoError,
    IoError,
    Timeout,
    InvalidSchema,
    InvalidChecksum,
    InvalidMnemonic,
    InsufficientSpace,
}

/// Structured error information within CliError.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorObject {
    /// Machine-readable error code from enumerated set
    pub code: CliErrorCode,

    /// Human-readable error description (sanitized, no sensitive data)
    pub message: String,
}

/// Error response from CLI when operations fail.
/// Deserialized from stdout JSON.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CliError {
    /// Always false for error responses
    pub success: bool,

    /// Structured error information
    pub error: ErrorObject,

    /// Request identifier for tracing
    pub request_id: String,

    /// CLI version for debugging
    pub cli_version: String,

    /// Time elapsed before failure (milliseconds)
    pub duration_ms: u64,
}

// ============================================================================
// Dashboard State Types
// ============================================================================

/// Global application state managed by Tauri state.
/// Shared between Rust backend commands.
#[derive(Debug, Default)]
pub struct DashboardState {
    /// Currently selected wallet ID (None if no wallet selected)
    pub selected_wallet_id: Option<String>,

    /// Array of all available wallets loaded from USB
    pub wallets: Vec<Wallet>,

    /// Addresses for currently selected wallet (empty if no wallet selected)
    pub addresses: Vec<Address>,

    /// USB device detection status
    pub usb_detected: bool,

    /// Current USB mount point (None if not detected)
    pub usb_path: Option<String>,
}
```

---

## Go Type Definitions

```go
// ============================================================================
// CLI Output Types (Go CLI)
// ============================================================================

package main

import (
    "time"
)

// Wallet represents the wallet metadata returned in CLI responses.
type Wallet struct {
    // Unique wallet identifier (UUID v4)
    ID string `json:"id"`

    // User-assigned wallet name (max 50 chars)
    Name string `json:"name,omitempty"`

    // Wallet creation timestamp (RFC3339)
    CreatedAt time.Time `json:"created_at"`

    // Whether BIP39 passphrase was used
    UsesPassphrase bool `json:"uses_passphrase"`

    // Relative path to addresses.json file
    AddressesFilePath string `json:"addresses_file_path"`
}

// AddressCategory represents the blockchain category for filtering.
type AddressCategory string

const (
    CategoryBaseChains    AddressCategory = "base"
    CategoryLayer2        AddressCategory = "layer2"
    CategoryRegional      AddressCategory = "regional"
    CategoryCosmos        AddressCategory = "cosmos"
    CategoryAlternativeEVM AddressCategory = "alt_evm"
    CategorySpecialized   AddressCategory = "specialized"
)

// Address represents a derived cryptocurrency address.
type Address struct {
    // Full blockchain name
    Blockchain string `json:"blockchain"`

    // Ticker symbol (uppercase)
    Symbol string `json:"symbol"`

    // SLIP-44 coin type
    CoinType uint32 `json:"coin_type"`

    // BIP44 account index
    Account uint32 `json:"account"`

    // BIP44 change index
    Change uint32 `json:"change"`

    // BIP44 address index
    Index uint32 `json:"index"`

    // Derived address string
    Address string `json:"address"`

    // Full derivation path
    Path string `json:"path"`

    // Blockchain category
    Category AddressCategory `json:"category"`
}

// AddressesFile represents the addresses.json file structure.
type AddressesFile struct {
    // Semantic version of file format
    SchemaVersion string `json:"schema_version"`

    // Foreign key to wallet
    WalletID string `json:"wallet_id"`

    // File generation timestamp
    GeneratedAt time.Time `json:"generated_at"`

    // Total address count (must be 54)
    TotalCount uint32 `json:"total_count"`

    // SHA-256 checksum of addresses array
    Checksum string `json:"checksum"`

    // Array of addresses
    Addresses []Address `json:"addresses"`
}

// CliResponse represents successful CLI operation output to stdout.
type CliResponse struct {
    // Always true for success
    Success bool `json:"success"`

    // Wallet object (optional)
    Wallet *Wallet `json:"wallet,omitempty"`

    // Mnemonic phrase (only if RETURN_MNEMONIC=true)
    Mnemonic string `json:"mnemonic,omitempty"`

    // Unique request identifier
    RequestID string `json:"request_id"`

    // CLI semantic version
    CLIVersion string `json:"cli_version"`

    // Operation duration in milliseconds
    DurationMs uint64 `json:"duration_ms"`

    // Non-fatal warnings
    Warnings []string `json:"warnings"`
}

// CliErrorCode represents machine-readable error codes.
type CliErrorCode string

const (
    ErrInvalidPassword   CliErrorCode = "INVALID_PASSWORD"
    ErrUSBNotFound       CliErrorCode = "USB_NOT_FOUND"
    ErrWalletExists      CliErrorCode = "WALLET_EXISTS"
    ErrCrypto            CliErrorCode = "CRYPTO_ERROR"
    ErrIO                CliErrorCode = "IO_ERROR"
    ErrTimeout           CliErrorCode = "TIMEOUT"
    ErrInvalidSchema     CliErrorCode = "INVALID_SCHEMA"
    ErrInvalidChecksum   CliErrorCode = "INVALID_CHECKSUM"
    ErrInvalidMnemonic   CliErrorCode = "INVALID_MNEMONIC"
    ErrInsufficientSpace CliErrorCode = "INSUFFICIENT_SPACE"
)

// ErrorObject represents structured error information.
type ErrorObject struct {
    // Error code from enumerated set
    Code CliErrorCode `json:"code"`

    // Human-readable error message (sanitized)
    Message string `json:"message"`
}

// CliError represents error response output to stdout.
type CliError struct {
    // Always false for errors
    Success bool `json:"success"`

    // Structured error information
    Error ErrorObject `json:"error"`

    // Request identifier for tracing
    RequestID string `json:"request_id"`

    // CLI version
    CLIVersion string `json:"cli_version"`

    // Time elapsed before failure
    DurationMs uint64 `json:"duration_ms"`
}

// Example usage in CLI main.go
func outputSuccess(wallet *Wallet, mnemonic string, requestID string, startTime time.Time) {
    response := CliResponse{
        Success:    true,
        Wallet:     wallet,
        RequestID:  requestID,
        CLIVersion: "0.4.0",
        DurationMs: uint64(time.Since(startTime).Milliseconds()),
        Warnings:   []string{},
    }

    // Only include mnemonic if explicitly requested
    if os.Getenv("RETURN_MNEMONIC") == "true" {
        response.Mnemonic = mnemonic
    }

    // Output to stdout as single-line JSON
    json.NewEncoder(os.Stdout).Encode(response)
}

func outputError(code CliErrorCode, message string, requestID string, startTime time.Time) {
    response := CliError{
        Success: false,
        Error: ErrorObject{
            Code:    code,
            Message: message,
        },
        RequestID:  requestID,
        CLIVersion: "0.4.0",
        DurationMs: uint64(time.Since(startTime).Milliseconds()),
    }

    // Output to stdout as single-line JSON
    json.NewEncoder(os.Stdout).Encode(response)
}
```

---

## Security Considerations

### Sensitive Data Handling

1. **Mnemonic Phrase**
   - Never stored in Wallet entity
   - Only exists in encrypted form on USB
   - Only returned in CliResponse if `RETURN_MNEMONIC=true`
   - Displayed with 30-second countdown and platform-specific screenshot protection
   - Cleared from memory immediately after use

2. **Passwords**
   - Never logged or stored
   - Passed to CLI via environment variables (not command-line args)
   - Cleared from Tauri memory after subprocess completes
   - Minimum 12 characters with complexity requirements

3. **BIP39 Passphrase**
   - Never stored anywhere
   - Treated with same security as mnemonic
   - Required on each wallet access if originally used
   - Different passphrase = different wallet (plausible deniability)

4. **Private Keys**
   - Never exposed to Dashboard
   - CLI derives and uses keys in memory only
   - Immediately cleared after address derivation

### Tamper Detection

1. **Checksum Validation**
   - SHA-256 hash of addresses array in addresses.json
   - Validated on every file read
   - Any mismatch triggers corruption error

2. **Schema Versioning**
   - Forward-compatible design using semver
   - Dashboard validates schema_version before parsing
   - Prevents incompatible file format usage

### Error Information Exposure

1. **User-Facing Errors**
   - Generic, actionable messages only
   - No sensitive data (passwords, mnemonics, private keys)
   - No internal paths or system details

2. **Debug Logs**
   - Full error details (exit codes, stdout, stderr)
   - Only accessible to developers/advanced users
   - Never transmitted externally

---

## Next Steps

With the data model fully defined:

1. ✅ **Entity definitions** - All core entities documented with TypeScript/Rust/Go types
2. ✅ **Validation rules** - Complete validation logic for passwords, mnemonics, USB paths, wallet names
3. ✅ **State transitions** - All workflow states documented (create, import, display, error)
4. ✅ **Relationships** - ERD and cardinality rules defined
5. ✅ **Type definitions** - Complete type systems for all three languages
6. **Implementation** - Begin coding Tauri commands, React components, and CLI enhancements

